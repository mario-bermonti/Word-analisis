* Projectâ€™s development plan [75%]
** DONE Develop tests [100%]
*** DONE Determine length - SPECIFY DIFFICULTY WEIGHT
*** DONE Check silent letters [100%]
**** DONE has_silent_letters - SPECIFY DIFFICULTY WEIGHT
**** DONE has_silent_h
**** DONE has_silent_u
*** DONE Same sound letters - SPECIFY DIFFICULTY WEIGHT [100%]
**** DONE check_same_sound_letter
**** DONE has_same_sound_letters
**** DONE check_b_sound_swapping
**** DONE check_j_sound
**** DONE swap_g_for_j_check
**** DONE check_s_sound
**** DONE swap_c_for_s_check
**** DONE check_k_sound
**** DONE swap_q_for_k_check
**** DONE swap_c_for_k_check
**** DONE check_y_sound
**** DONE swap_y_for_y_check
**** DONE swap_l_for_y_check
*** DONE Anagrams [100%]
**** DONE count_anagrams
**** DONE check_anagrams
*** DONE Difficulty index [100%]
**** DONE General to the next methods: the user should call determine_total_difficulty_index and that method calls integrate
**** DONE determine_total_difficulty_index
**** DONE integrate_word_information
**** DONE Add the check_anagrams method and test it
** DONE Adjust difficulty weights
** DONE Specify the difficulty weights as parameters
** DONE Update checking anagram algorithm
*** DONE count_anagrams
*** DONE check_anagrams
** TODO Use pandas to store data
** DONE Better names (methods)
** DONE Better names (variables)
** DONE Update documentation (docstring)
** DONE Change how words are passed to the object (currently at init (makes debuggin inneficient))
** TODO Improve codes efficiency and readability
*** Most methods count the number of occurences using the same algorithm (use function)
*** Improve efficency (especially for checking anagrams) because it takes way too long for relative large databases
**** Ideas (in steps of complexity)
***** check word length before analyzing if words are anagrams
***** Filtering words by word length and only check for anagrams for words of same length (requieres using pandas from beginning)
***** Use parallel processing for the different lengths (described above)
** DONE Save results to file
** Features
*** TODO Allow the user to specify path
*** TODO Use module as CLI script (using main)
**** Requires the user to specify filename
** Tests [%]
*** Structure tests by testcases
*** Identify other test cases (edge cases)
* Documentation development
** TODO Improve documentation
*** Usage section
* Bug fixes
** Bug found
*** Words that have same sound but do not meet criteria (logical error)
There is a bug when checking letters with same sound that only have the
specified sound when a rule is met.

Currently, only the letter that actually needs to meet the rule is checked
to determine if it meets the rule, but the letter for which it would be
swapped is not checked and it needs to be.

E.g., The word conceptuoso has a c with an /s/ sound and a letter s. The letter c meets
the criteria because it is followed by the letter 'e' but the letter 's' is not followed
by a weak vocal and if swapped by the 'c' it would sound as a /k/ (conseptuoko), which is
not possible.

**** Proposed correction:
Use str.count() method with the actual substring that meets the criteria and the substring
for which it could be swapped and meets the criteria. The following code snippets proves this works.

#+begin_src python :exports none :session :results output
  # should not swapped
  word = 'conceptuoso'
  (word.count('ce') + word.count('ci')) * (word.count('se') + word.count('si'))


  # should swap
  word = 'conceptuosi'
  (word.count('ce') + word.count('ci')) * (word.count('se') + word.count('si'))
#+end_src

#+RESULTS:
: 0
: 1
